module SimulationsHelper
  def simulation_back_button(simulation)
    return nil unless simulation.execution_path.present? && simulation.execution_path.length > 0

    link_to step_simulation_path(simulation, back: true),
            class: "inline-flex items-center bg-white/50 dark:bg-gray-800/50 py-2 px-4 border border-slate-200 dark:border-slate-700 rounded-lg shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 hover:bg-white/80 dark:hover:bg-gray-800/80 transition-all duration-200 hover:scale-105" do
      raw('<svg class="w-4 h-4 mr-1.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>') + "Back"
    end
  end

  # Returns "Step X of Y" for linear workflows, "Step X" for branching/graph workflows.
  # Uses execution_path length to determine the user's position, since current_step_index
  # tracks array position (unreliable in graph mode where navigation uses current_node_uuid).
  def simulation_step_counter(simulation, workflow)
    current = (simulation.execution_path&.length || 0) + 1
    has_branching = workflow.graph_mode? || workflow.steps&.any? { |s| %w[decision simple_decision].include?(s['type']) }

    if has_branching
      "Step #{current}"
    else
      total = workflow.steps&.length || 0
      "Step #{current} of #{total}"
    end
  end

  # Returns the inner content for a stepper pill: green checkmark for completed,
  # number badge for current/future, with a small step type icon.
  def simulation_stepper_step_content(path_item, index, is_completed, is_current)
    step_type = path_item['step_type'] || path_item['type']
    type_icon = step_type.present? ? step_type_svg_icon(step_type, css_classes: "w-3.5 h-3.5 inline mr-0.5 flex-shrink-0") : ""

    if is_completed
      checkmark = tag.svg(
        tag.path(d: "M5 13l4 4L19 7", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "2"),
        class: "w-3.5 h-3.5 inline mr-0.5 flex-shrink-0",
        fill: "none",
        stroke: "currentColor",
        viewBox: "0 0 24 24",
        xmlns: "http://www.w3.org/2000/svg"
      )
      safe_join([checkmark, type_icon, tag.span(index + 1, class: "font-semibold")])
    else
      safe_join([type_icon, tag.span(index + 1, class: "font-semibold")])
    end
  end

  # CSS classes for a stepper pill based on its state.
  def simulation_stepper_classes(is_completed, is_current)
    base = "inline-flex items-center px-3 py-1.5 rounded-full text-xs font-medium transition-all duration-200 whitespace-nowrap cursor-pointer"

    if is_current
      "#{base} bg-blue-500 text-white shadow-md ring-2 ring-blue-300 dark:ring-blue-400"
    elsif is_completed
      "#{base} bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300 hover:bg-green-200 dark:hover:bg-green-700"
    else
      "#{base} bg-gray-100 dark:bg-gray-800/50 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-800/80"
    end
  end

  # Generates a dynamic summary sentence for completed simulations.
  # E.g. "Completed 8 steps in 2m 14s — 4 questions answered, 2 routing decisions — resolved as Success"
  def simulation_summary_sentence(simulation)
    parts = []
    path = simulation.execution_path || []
    step_count = path.length

    # Duration
    duration_seconds = (simulation.updated_at - simulation.created_at).to_i
    duration_text = if duration_seconds < 60
      "#{duration_seconds}s"
    elsif duration_seconds < 3600
      "#{duration_seconds / 60}m #{duration_seconds % 60}s"
    else
      "#{duration_seconds / 3600}h #{(duration_seconds % 3600) / 60}m"
    end

    parts << "Completed #{step_count} #{'step'.pluralize(step_count)} in #{duration_text}"

    # Counts by step type
    type_counts = path.each_with_object(Hash.new(0)) { |item, counts| counts[item['step_type']] += 1 }
    type_parts = []
    type_parts << "#{type_counts['question']} #{'question'.pluralize(type_counts['question'])} answered" if type_counts['question'] > 0
    type_parts << "#{type_counts['decision']} routing #{'decision'.pluralize(type_counts['decision'])}" if type_counts['decision'] > 0
    type_parts << "#{type_counts['action']} #{'action'.pluralize(type_counts['action'])} performed" if type_counts['action'] > 0
    type_parts << "#{type_counts['checkpoint']} #{'checkpoint'.pluralize(type_counts['checkpoint'])}" if type_counts['checkpoint'] > 0
    parts << type_parts.join(", ") if type_parts.any?

    # Resolution/escalation info
    results = simulation.results || {}
    if results['_resolution'].present?
      resolution_type = results['_resolution']['type']&.titleize
      parts << "resolved as #{resolution_type}" if resolution_type.present?
    elsif results['_escalation'].present?
      escalation_type = results['_escalation']['type']&.titleize
      parts << "escalated to #{escalation_type}" if escalation_type.present?
    end

    parts.join(" — ")
  end

  # Humanizes raw result keys: strips step_ prefix, replaces underscores, titleizes.
  # E.g. "step_6_outlook_success_check" → "Outlook Success Check"
  def format_result_key(key)
    formatted = key.to_s
    formatted = formatted.sub(/\Astep_\d+_/, '')
    formatted = formatted.tr('_', ' ')
    formatted.titleize
  end

  # Groups regular results into categorized subsections for display.
  # Returns an array of { label: String, results: Hash } hashes, skipping empty groups.
  def categorize_simulation_results(simulation)
    results = (simulation.results || {}).reject { |k, _| k.to_s.start_with?('_') }
    return [] if results.empty?

    input_keys = (simulation.inputs || {}).keys.map(&:to_s)

    user_inputs = results.select { |k, _| input_keys.include?(k.to_s) }
    outcomes = results.reject { |k, _| input_keys.include?(k.to_s) }

    groups = []
    groups << { label: "User Inputs", results: user_inputs } if user_inputs.any?
    groups << { label: "Outcomes", results: outcomes } if outcomes.any?
    groups
  end
end
